#include <stdio.h>
#include "lup_functions.h"

int main(int argc, char **argv) {
    if(argc != 4) {
        fprintf(stderr, "Usage: %s filename_in N filename_out\n", argv[0]);
        fprintf(stderr, "\tN denotes matrix size\n");
        fprintf(stderr, "\tfilename_in - file with initial matrix\n");
        fprintf(stderr, "\tfilename_out - file for results matrix\n");
        return 1;
    }

    char *filename_in = argv[1];
    int N = atoi(argv[2]); // size of matrix
    char *filename_out = argv[3];
    MPI_Init(&argc, &argv);
    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    if(size == 1) {
        fprintf(stderr, "At least 2 processes expected\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }
    int i;
    // calculate how many rows goes to every process
    int rows_per_process = N / (size - 1); // (size-1) because rank=0 does not work here
    int rows_per_last_process = N - (size - 2) * rows_per_process;
    int rp = (rank == size - 1) ? rows_per_last_process : rows_per_process; // actual rows_per_process for every process
                                                                            // not significant at rank=0

    double *prev_row = (double*)malloc(sizeof(double) * N); // rank=0 receive this too in MPI_Bcast
                                                            // but it does not use it
    int i_rank; // rank of process, which contains row 'i' (currently processed row)

    double *A = NULL; // initial matrix
    MPI_Win win_A; // window for matrix A (initial matrix)
    if(rank == 0) {
        // read matrix A from file
        LUP_mpi_matrix_create(&A, N);
        FILE *f_in;
        f_in = fopen(filename_in, "rb");
        if(!f_in) {
            fprintf(stderr, "Unable to open file '%s'\n", filename_in);
            MPI_Abort(MPI_COMM_WORLD, 1);
        }
        for(i = 0; i < N; i++) { // fill array with data generated by lup_generate_matrix
            fread(A + i*N, sizeof(double), N, f_in); // row by row
        }
        fclose(f_in);
        // end read matrix A from file
    } // rank=0
    // spread rows across processes
    MPI_Win_create(A, N*N*sizeof(double), sizeof(double), MPI_INFO_NULL, MPI_COMM_WORLD, &win_A);
    MPI_Win_fence(0, win_A);
    double *rows = NULL; // local rows for processes with rank>0
    if(rank > 0) {
        rows = (double*)malloc(sizeof(double) * N * rp);
        MPI_Get(rows, N * rp, MPI_DOUBLE, 0, (rank - 1) * rows_per_process * N, N * rp, MPI_DOUBLE, win_A);
    } // rank>0
    MPI_Win_fence(0, win_A);

    
    double *C = NULL; // results matrix
    int *P = NULL; // identity matrix
    FILE *f_out;
    if(rank == 0) {
        C = NULL; // results matrix
        P = NULL; // identity matrix
        LUP_mpi_matrix_create(&C, N);
        P = (int*)malloc(sizeof(int) * N); // matrix P is represented as vector of indexes
                                           // P[i] = k, i - row, k = column, where '1' is located
                                           // to swap rows 'i' and 'j' in P, swap elements P[i] and P[j]
        for(i = 0; i < N; i++) {
            P[i] = i;
        }
        f_out = fopen(filename_out, "w");
        if(!f_out) {
            fprintf(stderr, "Unable to open file '%s'\n", filename_out);
            return 1;
        }
    }

    MPI_Win win_C;
    MPI_Win_create(C, N*N*sizeof(double), sizeof(double), MPI_INFO_NULL, MPI_COMM_WORLD, &win_C);

    double *pivot_values = NULL;
    int *pivot_rows = NULL;
    int proc;
    double proc_max_value;
    int proc_max_row;
    if(rank == 0) {
        pivot_values = (double*)malloc(sizeof(double) * size);
        pivot_rows = (int*)malloc(sizeof(int) * size);
    }
    int first_row = -1;
    int last_row = -1;
    if(rank > 0) {
        // every process finds out, which rows it processes
        // for example
        // if we have 10 rows and 4 processes (including rank=0)
        // then processes with rank 1,2,3 receive rows from rank=0
        // rank=1 receives rows from 0 to 2 (including 2), 3 rows  
        // rank=2 receives rows from 3 to 5 (including 5), 3 rows  3+3+4=10
        // rank =3 reeives rows from 6 to 9 (including 9), 4 rows  
        LUP_find_first_last_rows(rank, size, N, rows_per_process, &first_row, &last_row);
    }

    double pivot_value;
    int pivot_row;
    int max_row; // max_row - row with maximum element in column 'i'
                 // maximum element is searched for in lines i+1 to N-1 (including N-1) of column 'i'
    int max_rank; // rank of process, which contains max_row
    double Cii;

    MPI_Win win_rows;
    MPI_Win_create(rows, N * rp * sizeof(double), sizeof(double), MPI_INFO_NULL, MPI_COMM_WORLD, &win_rows);
    MPI_Win win_pivot_value, win_pivot_row;
    MPI_Win_create(&pivot_value, sizeof(double), sizeof(double), MPI_INFO_NULL, MPI_COMM_WORLD, &win_pivot_value);
    MPI_Win_create(&pivot_row, sizeof(int), sizeof(int), MPI_INFO_NULL, MPI_COMM_WORLD, &win_pivot_row);
    MPI_Win win_max_row;
    MPI_Win_create(&proc_max_row, sizeof(int), sizeof(int), MPI_INFO_NULL, MPI_COMM_WORLD, &win_max_row);
    MPI_Win win_max_rank;
    MPI_Win_create(&max_rank, sizeof(int), sizeof(int), MPI_INFO_NULL, MPI_COMM_WORLD, &win_max_rank);
    MPI_Win win_i_rank;
    MPI_Win_create(&i_rank, sizeof(int), sizeof(int), MPI_INFO_NULL, MPI_COMM_WORLD, &win_i_rank);

    for(i = 0; i < N - 1; i++) {
        MPI_Win_fence(0, win_pivot_value);
        MPI_Win_fence(0, win_pivot_row);
        if(rank == 0) { // find global maximum
            proc_max_value = 0;
            proc_max_row = -1;
            int proc_last_row;
            for(proc = 1; proc < size; proc++) {
                if(proc == size - 1) proc_last_row = N-1;
                else proc_last_row = proc*rows_per_process - 1;
                if(i <= proc_last_row) {
                    MPI_Get(pivot_values + proc, 1, MPI_DOUBLE, proc, 0, 1, MPI_DOUBLE, win_pivot_value);
                    MPI_Get(pivot_rows + proc, 1, MPI_INT, proc, 0, 1, MPI_INT, win_pivot_row);
                }
            }
        }
        if(rank > 0) { // find local maximum
            if(LUP_mpi_find_pivot(rows, first_row, last_row, i, N, &pivot_value, &pivot_row) == 0) { // pivot row found
                if(fabs(pivot_value) < 1E-6) { // too close to 0 (zero)
                    fprintf(stderr, "Matrix is singular\n");
                    MPI_Abort(MPI_COMM_WORLD, 1);
                }
            } // now rank=0 can find global maximum by accessing pivot_value and pivot_row via MPI_Get
        }
        MPI_Win_fence(0, win_pivot_value);
        MPI_Win_fence(0, win_pivot_row);
        // rank=0 received pivot_values and pivot_rows
        // now we can find global maximum
        if(rank == 0 ) {
            proc_max_value = 0;
            proc_max_row = -1;
            int proc_last_row;
            int proc_first_row = -1;
            i_rank = -1;
            for(proc = 1; proc < size; proc++) {
                if(proc == size - 1) proc_last_row = N-1;
                else proc_last_row = proc*rows_per_process - 1;
                proc_first_row = (proc - 1) * rows_per_process;
                if(i >= proc_first_row && i <= proc_last_row)
                    i_rank = proc;
                if(i <= proc_last_row) {
                    if(pivot_values[proc] > proc_max_value) {
                        proc_max_value = pivot_values[proc];
                        proc_max_row = pivot_rows[proc];
                        max_rank = proc;
                    }
                }
            }
            //swap rows in P
            int tmp = P[proc_max_row];
            P[proc_max_row] = P[i];
            P[i] = tmp;
        } // we found global maximum
        // now all processes with rank>0 can receive global maximum
        MPI_Win_fence(0, win_max_row);
        MPI_Win_fence(0, win_max_rank);
        MPI_Win_fence(0, win_i_rank);
        if(rank > 0) {
            MPI_Get(&max_row, 1, MPI_INT, 0, 0, 1, MPI_INT, win_max_row);
            MPI_Get(&max_rank, 1, MPI_INT, 0, 0, 1, MPI_INT, win_max_rank);
            MPI_Get(&i_rank, 1, MPI_INT, 0, 0, 1, MPI_INT, win_i_rank);
        }
        MPI_Win_fence(0, win_max_row);
        MPI_Win_fence(0, win_max_rank);
        MPI_Win_fence(0, win_i_rank);
        // now swap rows
        if(rank > 0) {
            // both rows are in the same process
            if(i >= first_row && i <= last_row && max_row >= first_row && max_row <= last_row) { 
                LUP_mpi_swap_rows(rows, i, max_row, first_row, N);
            // otherwise rows are in different processes
            } else if(i >= first_row && i <= last_row) {
                MPI_Sendrecv_replace(rows + (i - first_row)*N, N, MPI_DOUBLE, max_rank, 0, max_rank, 0, \
                    MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            } else if(max_row >= first_row && max_row <= last_row) {
                MPI_Sendrecv_replace(rows + (max_row - first_row)*N, N, MPI_DOUBLE, i_rank, 0, i_rank, 0, \
                    MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            }
        }
        //spread C[i][i] across processes
        if(rank > 0) {
            if(i >= first_row && i <= last_row) {
                MPI_Bcast(rows + (i - first_row)*N + i, 1, MPI_DOUBLE, rank, MPI_COMM_WORLD); 
                Cii = rows[(i-first_row)*N + i];
            } else {
                MPI_Bcast(&Cii, 1, MPI_DOUBLE, i_rank, MPI_COMM_WORLD);
            }
        }
        if(rank == 0)
            MPI_Bcast(&Cii, 1, MPI_DOUBLE, i_rank, MPI_COMM_WORLD);
        MPI_Win_fence(0, win_rows);
        if(rank > 0 && rank != i_rank) {
            MPI_Get(prev_row, N, MPI_DOUBLE, i_rank, (i - (i_rank - 1)*rows_per_process)*N, N, MPI_DOUBLE, win_rows);
        }
        MPI_Win_fence(0, win_rows);
        int j, k;
        int start_row, end_row;
        if((i+1) <= last_row) {
            if((i+1) >= first_row)
                start_row = i+1;
            else
                start_row = first_row;
            end_row = last_row - first_row;
            start_row = start_row - first_row;
            for(j = start_row; j <= end_row; j++) {
                rows[j*N + i] /= Cii;
                for(k = i+1; k < N; k++) {
                    if(rank == i_rank)
                        rows[j*N + k] -= rows[j*N + i] * rows[(i-first_row) * N + k];
                    else
                        rows[j*N + k] -= rows[j*N + i] * prev_row[k];
                }
            }
        }
    }


    if(rank == 0) {
        MPI_Win_fence(0, win_rows);
        int proc_first_row, proc_last_row;
        for(proc = 1; proc < size; proc++) {
            if(proc == size - 1) proc_last_row = N-1;
            else proc_last_row = proc*rows_per_process - 1;
            proc_first_row = (proc - 1) * rows_per_process;
            MPI_Get(C + proc_first_row * N, (proc_last_row - proc_first_row + 1) * N, MPI_DOUBLE, proc,\
                0, (proc_last_row - proc_first_row + 1) * N, MPI_DOUBLE, win_rows);
        }
        MPI_Win_fence(0, win_rows);
        int k;
        fprintf(f_out, "C\n");
        for(i = 0; i < N; i++) {
            for(k = 0; k < N; k++) {
                fprintf(f_out, "%f\t", C[i*N + k]);
            }
            fprintf(f_out, "\n");
        }
        fprintf(f_out, "P\n");
        for(i = 0; i < N; i++) {
            for(k = 0; k < N; k++) {
                if(k == P[i]) {
                    fprintf(f_out, "1\t");
                } else {
                    fprintf(f_out, "0\t");
                }
            }
            fprintf(f_out, "\n");
        }
        fclose(f_out);
        LUP_mpi_matrix_free(&A);
        LUP_mpi_matrix_free(&C);
        free(P);
        free(pivot_values);
        free(pivot_rows);
    } // if rank==0

    if(rank > 0) {
        MPI_Win_fence(0, win_rows);
        MPI_Win_fence(0, win_rows);
        free(rows);
        rows = NULL;
    }

    free(prev_row);
    MPI_Win_free(&win_A);
    MPI_Win_free(&win_C);
    MPI_Win_free(&win_rows);
    MPI_Win_free(&win_pivot_value);
    MPI_Win_free(&win_pivot_row);
    MPI_Win_free(&win_max_row);
    MPI_Win_free(&win_i_rank);
    MPI_Win_free(&win_max_rank);

    MPI_Barrier(MPI_COMM_WORLD);
    MPI_Finalize();
    return 0;
}
