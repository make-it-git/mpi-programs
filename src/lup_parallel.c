#include <stdio.h>
#include "lup_functions.h"
#include <unistd.h>

int main(int argc, char **argv) {
    if(argc != 3) {
        fprintf(stderr, "Usage: %s filename N\n", argv[0]);
        fprintf(stderr, "\tN denotes matrix size\n");
        return 1;
    }
    char *filename = argv[1];
    int N = atoi(argv[2]);
    MPI_Init(&argc, &argv);
    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    if(size == 1) {
        fprintf(stderr, "At least 2 processes expected\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }
    double *A = NULL;
    double *C = NULL;
    int i;
    if(rank == 0) { //read matrix A from file
        LUP_mpi_matrix_create(&A, N);
        LUP_mpi_matrix_create(&C, N);//matrix C will contain result
        FILE *f;
        f = fopen(filename, "rb");
        if(!f) {
            fprintf(stderr, "Unable to open file '%s'\n", filename);
            MPI_Abort(MPI_COMM_WORLD, 1);
        }
        for(i = 0; i < N; i++) {//fill array with data generated by lup_generate_matrix
            fread(A + i*N, sizeof(double), N, f);
        }
        fclose(f);
        /*int k;
        for(i = 0; i < N; i++) {
            for(k = 0; k < N; k++) {
                printf("%f\t", A[i*N + k]);
            }
            printf("\n");
        }*/
    }

    //calculate how many rows goes to every process
    int rows_per_process = N / (size - 1); //(size-1), because rank=0 does not work here
    int rows_per_last_process = N - (size - 2) * rows_per_process;
    int rp = (rank == size - 1) ? rows_per_last_process : rows_per_process;
    /*if(rank == size-1) {
        rows_per_process = N - (size-2)*rows_per_process;
    }*/
    double *rows = NULL; //buffer for rows at every process with rank > 0
    if(rank > 0) {
        //int rp = (rank == size - 1) ? rows_per_last_process : rows_per_process;
        rows = (double*)malloc(sizeof(double) * N * rp);
    }
    if(rank == 0) {
        int *sendcounts = (int*)malloc(sizeof(int) * size);
        int *displs = (int*)malloc(sizeof(int) * size);
        sendcounts[0] = displs[0] = 0;//rank=0 does not send anything (and does not receive, too)
        for(i = 1; i < size; i++) {
            if(i == size-1) {
                sendcounts[i] = rows_per_last_process * N;
            } else {
                sendcounts[i] = rows_per_process * N;
            }
            displs[i] = (i-1) * sendcounts[i-1];
        }
        //spread rows across processes
        MPI_Scatterv(A, sendcounts, displs, MPI_DOUBLE, NULL, 0, MPI_DOUBLE, 0, MPI_COMM_WORLD);
        free(sendcounts);
        free(displs);
    } else {
        //int rp = (rank == size - 1) ? rows_per_last_process : rows_per_process;
        MPI_Scatterv(NULL, NULL, NULL, MPI_DOUBLE, rows, rp*N, MPI_DOUBLE, 0, MPI_COMM_WORLD);
    }
    if(rank > 0) {
        sleep(rank);
        printf("rank=%d:\n", rank);
        //int rp = (rank == size - 1) ? rows_per_last_process : rows_per_process;
        int k;
        for(i = 0; i < rp; i++) {
            for(k = 0; k < N; k++) {
                printf("%f\t", rows[i*N + k]);
            }
            printf("\n");
        }
    }
    /*if(rank > 0) {
        //int rp = (rank == size - 1) ? rows_per_last_process : rows_per_process;
        printf("rank=%d, rows=%d\n", rank, rp);
    }*/
    if(rank == 0) {
        LUP_mpi_matrix_free(&A);
        LUP_mpi_matrix_free(&C);
    }
    if(rank > 0) {
        free(rows);
        rows = NULL;
    }
    MPI_Barrier(MPI_COMM_WORLD);
    MPI_Finalize();
    return 0;
}
